import os
import time
import hmac
import hashlib
import json
import aiohttp
from aiogram import Bot, Dispatcher, types
from aiogram.contrib.fsm_storage.memory import MemoryStorage
from aiogram.dispatcher import FSMContext
from aiogram.dispatcher.filters.state import State, StatesGroup
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.utils import executor
from aiogram.utils.exceptions import MessageNotModified
from dotenv import load_dotenv

load_dotenv()
BOT_TOKEN = os.getenv("BOT_TOKEN")
ALLOWED_USERS = [int(user_id.strip()) for user_id in os.getenv("ALLOWED_USER_ID", "0").split(",")]
BINANCE_API = "https://api.binance.com"
BINANCE_FUTURES_API = "https://fapi.binance.com"
BYBIT_API = "https://api.bybit.com"
WALLEX_API = "https://api.wallex.ir/v1"
BINANCE_API_KEY = os.getenv("BINANCE_API_KEY")
BINANCE_SECRET_KEY = os.getenv("BINANCE_SECRET_KEY")
BYBIT_API_KEY = os.getenv("BYBIT_API_KEY")
BYBIT_SECRET_KEY = os.getenv("BYBIT_SECRET_KEY")
COINEX_API = "https://api.coinex.com"
COINEX_API_KEY = os.getenv("COINEX_API_KEY")
COINEX_SECRET_KEY = os.getenv("COINEX_SECRET_KEY")

# --- FSM Storage and Bot Initialization ---
storage = MemoryStorage()
bot = Bot(token=BOT_TOKEN)
dp = Dispatcher(bot, storage=storage)

# --- FSM States ---
class PositionState(StatesGroup):
    waiting_for_tp = State()
    waiting_for_sl = State()
    waiting_for_leverage = State()

# --- Keyboards ---

# Main Menu
main_keyboard = InlineKeyboardMarkup(row_width=3)
main_keyboard.add(
    InlineKeyboardButton("Rate", callback_data="get_prices"),
    InlineKeyboardButton("Binance", callback_data="binance_menu"),
    InlineKeyboardButton("Bybit", callback_data="bybit_menu"),
    InlineKeyboardButton("CoinEx", callback_data="coinex_menu")
)

# Binance Menu
binance_keyboard = InlineKeyboardMarkup(row_width=2)
binance_keyboard.add(
    InlineKeyboardButton("Balance", callback_data="binance_balance"),
    InlineKeyboardButton("Positions", callback_data="binance_positions")
)
binance_keyboard.add(InlineKeyboardButton("Main Menu", callback_data="main_menu"))

# Bybit Menu
bybit_keyboard = InlineKeyboardMarkup(row_width=2)
bybit_keyboard.add(
    InlineKeyboardButton("Balance", callback_data="bybit_balance"),
    InlineKeyboardButton("Positions", callback_data="bybit_positions")
)
bybit_keyboard.add(InlineKeyboardButton("Main Menu", callback_data="main_menu"))

# CoinEx Menu
coinex_keyboard = InlineKeyboardMarkup(row_width=2)
coinex_keyboard.add(
    InlineKeyboardButton("Balance", callback_data="coinex_balance"),
    InlineKeyboardButton("Positions", callback_data="coinex_positions")
)
coinex_keyboard.add(InlineKeyboardButton("Main Menu", callback_data="main_menu"))


async def get_position_keyboard(exchange, symbol, position_index):
    keyboard = InlineKeyboardMarkup(row_width=2)
    base_data = f"{exchange}_position_{position_index}"

    keyboard.add(
        InlineKeyboardButton("TP", callback_data=f"{base_data}_set_tp"),
        InlineKeyboardButton("SL", callback_data=f"{base_data}_set_sl")
    )
    keyboard.add(
        InlineKeyboardButton("Close 100%", callback_data=f"{base_data}_close_100"),
        InlineKeyboardButton("Close 75%", callback_data=f"{base_data}_close_75")
    )
    keyboard.add(
        InlineKeyboardButton("Close 50%", callback_data=f"{base_data}_close_50"),
        InlineKeyboardButton("Close 25%", callback_data=f"{base_data}_close_25")
    )
    keyboard.add(
        InlineKeyboardButton("Leverage", callback_data=f"{base_data}_change_leverage"),
        InlineKeyboardButton("Size", callback_data=f"{base_data}_change_size") # Placeholder
    )
    keyboard.add(InlineKeyboardButton("Main Menu", callback_data="main_menu"))

    return keyboard


# --- Signature Generators ---

async def get_binance_signature(query_string):
    return hmac.new(
        BINANCE_SECRET_KEY.encode('utf-8'),
        query_string.encode('utf-8'),
        hashlib.sha256
    ).hexdigest()


async def get_bybit_signature(params, recv_window='5000'):
    timestamp = str(int(time.time() * 1000))
    param_str = '&'.join([f'{key}={value}' for key, value in sorted(params.items())])
    to_sign = str(timestamp) + BYBIT_API_KEY + recv_window + param_str

    signature = hmac.new(
        bytes(BYBIT_SECRET_KEY, 'utf-8'),
        bytes(to_sign, 'utf-8'),
        hashlib.sha256
    ).hexdigest()

    return signature, timestamp


async def get_coinex_signature(method, path, body_or_params, timestamp):
    if isinstance(body_or_params, dict):
        body_or_params = json.dumps(body_or_params)
        
    prepared_str = f"{method}{path}{body_or_params}{timestamp}{COINEX_SECRET_KEY}"
    signature = hashlib.sha256(prepared_str.encode('utf-8')).hexdigest()
    return signature


# --- Price Fetching ---
async def get_all_binance_prices():
    async with aiohttp.ClientSession() as session:
        async with session.get(f"{BINANCE_API}/api/v3/ticker/price") as r:
            data = await r.json()
            prices = {}
            for item in data:
                sym = item.get('symbol', '')
                try:
                    price = float(item.get('price', '0'))
                except (TypeError, ValueError):
                    continue
                prices[sym] = price
            return prices


async def fetch_prices():
    try:
        async with aiohttp.ClientSession() as session:
            # Binance prices
            coins = ["BTCUSDT", "ETHUSDT", "SOLUSDT"]
            binance = {}
            for coin in coins:
                async with session.get(f"{BINANCE_API}/api/v3/ticker/price?symbol={coin}") as r:
                    data = await r.json()
                    binance[coin[:-4]] = float(data["price"])

            # Bybit prices
            bybit = {}
            for coin in coins:
                async with session.get(f"{BYBIT_API}/v5/market/tickers?category=spot&symbol={coin}") as r:
                    data = await r.json()
                    if data.get('result', {}).get('list'):
                        bybit[coin[:-4]] = float(data['result']['list'][0]['lastPrice'])

            # Wallex USDT price
            usdt_tmn = "N/A"
            async with session.get(f"{WALLEX_API}/markets") as r:
                data = await r.json()
                if "result" in data and "symbols" in data["result"]:
                    if "USDTTMN" in data["result"]["symbols"]:
                        market_data = data["result"]["symbols"]["USDTTMN"]
                        if "stats" in market_data and "lastPrice" in market_data["stats"]:
                            price = float(market_data["stats"]["lastPrice"])
                            usdt_tmn = f"{price:,.0f} Toman"

            return (
                "Real-time cryptocurrency rates:\n\n"
                f"USDT (WALLEX): {usdt_tmn}\n\n"
                f"Binance:\n"
                f"BTC: ${binance.get('BTC', 0):,.0f}\n"
                f"ETH: ${binance.get('ETH', 0):,.0f}\n"
                f"SOL: ${binance.get('SOL', 0):,.2f}\n\n"
                f"Bybit:\n"
                f"BTC: ${bybit.get('BTC', 0):,.0f}\n"
                f"ETH: ${bybit.get('ETH', 0):,.0f}\n"
                f"SOL: ${bybit.get('SOL', 0):,.2f}"
            )
    except Exception as e:
        print(f"Error in fetch_prices: {str(e)}")
        return "Error fetching prices"

# --- Balance & Position Fetching (Binance) ---
async def fetch_binance_balance():
    try:
        timestamp = int(time.time() * 1000)
        params = f"timestamp={timestamp}"
        signature = await get_binance_signature(params)
        headers = {'X-MBX-APIKEY': BINANCE_API_KEY}

        async with aiohttp.ClientSession() as session:
            spot_url = f"{BINANCE_API}/api/v3/account?{params}&signature={signature}"
            async with session.get(spot_url, headers=headers) as response:
                spot_data = await response.json()

            futures_params = f"timestamp={timestamp}"
            futures_signature = await get_binance_signature(futures_params)
            futures_url = f"{BINANCE_FUTURES_API}/fapi/v2/account?{futures_params}&signature={futures_signature}"

            async with session.get(futures_url, headers=headers) as response:
                futures_data = await response.json()

            prices = await get_all_binance_prices()

            message = "Binance Balance:\n\n"
            message += "Spot:\n"
            total_spot_usdt = 0

            if 'balances' in spot_data:
                spot_balances = []
                for asset in spot_data['balances']:
                    symbol = asset['asset']
                    free = float(asset['free'])
                    locked = float(asset['locked'])
                    total = free + locked
                    if total <= 0: continue
                    usdt_value = 0
                    if symbol == 'USDT': usdt_value = total
                    elif f"{symbol}USDT" in prices: usdt_value = total * prices[f"{symbol}USDT"]
                    elif symbol == 'USDC': usdt_value = total

                    if usdt_value >= 0.01:
                        total_spot_usdt += usdt_value
                        spot_balances.append({'symbol': symbol, 'amount': total, 'usdt': usdt_value})

                spot_balances.sort(key=lambda x: x['usdt'], reverse=True)
                for balance in spot_balances:
                    if balance['symbol'] == 'USDT':
                        message += f"{balance['symbol']}: {balance['amount']:,.2f}\n"
                    else:
                        message += f"{balance['symbol']}: {balance['amount']:,.8f} (≈ ${balance['usdt']:,.2f})\n"

            message += f"\nTotal Spot: ${total_spot_usdt:,.2f}\n"
            message += "\nFutures:\n"
            total_futures_usdt = 0

            if 'assets' in futures_data:
                futures_balances = []
                for asset in futures_data['assets']:
                    symbol = asset['asset']
                    wallet_balance = float(asset['walletBalance'])
                    if wallet_balance > 0 and symbol == 'USDT':
                        futures_balances.append({'symbol': symbol, 'amount': wallet_balance, 'usdt': wallet_balance})
                        total_futures_usdt += wallet_balance
                futures_balances.sort(key=lambda x: x['usdt'], reverse=True)
                for balance in futures_balances:
                    message += f"{balance['symbol']}: ${balance['amount']:,.2f}\n"

            message += f"\nTotal Futures: ${total_futures_usdt:,.2f}\n"
            message += f"\nTotal: ${(total_spot_usdt + total_futures_usdt):,.2f}"
            return message

    except Exception as e:
        print(f"Error in fetch_binance_balance: {str(e)}")
        return "Error fetching Binance balance"


async def fetch_binance_positions():
    try:
        timestamp = int(time.time() * 1000)
        params_str = f"timestamp={timestamp}"
        signature = await get_binance_signature(params_str)
        headers = {'X-MBX-APIKEY': BINANCE_API_KEY}

        async with aiohttp.ClientSession() as session:
            positions_url = f"{BINANCE_FUTURES_API}/fapi/v2/positionRisk?{params_str}&signature={signature}"
            async with session.get(positions_url, headers=headers) as response:
                positions_data = await response.json()

            active_positions = []
            for position in positions_data:
                size = float(position['positionAmt'])
                if size == 0: continue
                entry_price = float(position['entryPrice'])
                mark_price = float(position['markPrice'])
                leverage = float(position['leverage'])
                unreal_pnl = float(position['unRealizedProfit'])
                position_type = "Long" if size > 0 else "Short"
                roe = (mark_price - entry_price) / entry_price * 100 * leverage if size > 0 else (entry_price - mark_price) / entry_price * 100 * leverage

                active_positions.append({
                    'symbol': position['symbol'], 'type': position_type, 'size': abs(size),
                    'entry': entry_price, 'mark': mark_price, 'liq': float(position['liquidationPrice']),
                    'leverage': leverage, 'pnl': unreal_pnl, 'roe': roe
                })
            return active_positions
    except Exception as e:
        print(f"Error in fetch_binance_positions: {str(e)}")
        return []

# --- Balance & Position Fetching (Bybit) ---

async def fetch_bybit_balance():
    try:
        params = {'accountType': 'UNIFIED'}
        signature, timestamp = await get_bybit_signature(params)
        headers = {
            'X-BAPI-API-KEY': BYBIT_API_KEY, 'X-BAPI-SIGN': signature,
            'X-BAPI-TIMESTAMP': timestamp, 'X-BAPI-RECV-WINDOW': '5000'
        }
        url = f"{BYBIT_API}/v5/account/wallet-balance"
        async with aiohttp.ClientSession() as session:
            async with session.get(url, params=params, headers=headers) as response:
                data = await response.json()
                message = "Bybit Balance:\n\n"
                if data.get('retCode') == 0:
                    balances = data.get('result', {}).get('list', [])
                    if balances:
                        balance = balances[0]
                        message += f"Total Equity: {float(balance.get('totalEquity', '0')):,.2f} USDT\n"
                        message += f"Wallet Balance: {float(balance.get('totalWalletBalance', '0')):,.2f} USDT\n\n"
                        coins = balance.get('coin', [])
                        if coins:
                            message += "Details:\n"
                            for coin in coins:
                                if float(coin.get('walletBalance', '0')) > 0:
                                    coin_name = coin.get('coin', '')
                                    message += f"{coin_name}: {float(coin.get('walletBalance', '0')):,.8f}"
                                    if coin_name != 'USDT':
                                        message += f" (≈ ${float(coin.get('usdValue', '0')):,.2f})\n"
                                    else: message += "\n"
                else: message += f"Error: {data.get('retMsg', 'Unknown error')}"
                return message
    except Exception as e:
        print(f"Bybit Balance Error: {str(e)}")
        return "Error fetching Bybit balance"


async def fetch_bybit_positions():
    try:
        params = {'category': 'linear', 'settleCoin': 'USDT'}
        signature, timestamp = await get_bybit_signature(params)
        headers = {
            'X-BAPI-API-KEY': BYBIT_API_KEY, 'X-BAPI-SIGN': signature,
            'X-BAPI-TIMESTAMP': timestamp, 'X-BAPI-RECV-WINDOW': '5000'
        }
        url = f"{BYBIT_API}/v5/position/list"
        async with aiohttp.ClientSession() as session:
            async with session.get(url, params=params, headers=headers) as response:
                data = await response.json()
                active_positions = []
                if data.get('retCode') == 0:
                    for position in data.get('result', {}).get('list', []):
                        size = float(position.get('size', '0'))
                        if size == 0: continue
                        position_value = float(position.get('positionValue', '0'))
                        unrealized_pnl = float(position.get('unrealisedPnl', '0'))
                        active_positions.append({
                            'symbol': position.get('symbol', ''), 'type': "Long" if position.get('side') == "Buy" else "Short",
                            'size': size, 'entry': float(position.get('avgPrice', '0')),
                            'mark': float(position.get('markPrice', '0')), 'liq': float(position.get('liqPrice', '0')),
                            'leverage': float(position.get('leverage', '1')), 'pnl': unrealized_pnl,
                            'roe': (unrealized_pnl / position_value) * 100 if position_value != 0 else 0
                        })
                return active_positions
    except Exception as e:
        print(f"Bybit Positions Error: {str(e)}")
        return []

# --- Balance & Position Fetching (CoinEx) ---
async def fetch_coinex_balance():
    try:
        timestamp = str(int(time.time() * 1000))
        path = "/v2/assets/spot/balance"
        signature = await get_coinex_signature("GET", path, "", timestamp)
        headers = {
            'X-COINEX-KEY': COINEX_API_KEY, 'X-COINEX-SIGN': signature,
            'X-COINEX-TIMESTAMP': timestamp, 'Content-Type': 'application/json'
        }
        url = f"{COINEX_API}{path}"
        async with aiohttp.ClientSession() as session:
            async with session.get(url, headers=headers) as response:
                data = await response.json()
                if data.get('code') != 0: return f"Error: {data.get('message', 'Unknown error')}"
                message = "CoinEx Balance:\n\n"
                total_usdt = 0
                prices = {}
                try:
                    ticker_url = f"{COINEX_API}/v2/spot/market/ticker/all"
                    async with session.get(ticker_url) as ticker_response:
                        ticker_data = await ticker_response.json()
                        if ticker_data.get('code') == 0:
                            for market, ticker in ticker_data.get('data', {}).items():
                                if market.endswith('USDT'): prices[market[:-4]] = float(ticker['last'])
                except Exception as e: print(f"Error fetching CoinEx prices: {e}")
                
                for balance in data.get('data', []):
                    coin = balance.get('ccy')
                    total = float(balance.get('available', '0')) + float(balance.get('frozen', '0'))
                    if total > 0:
                        usdt_value = 0
                        if coin == 'USDT': usdt_value = total
                        elif coin in prices: usdt_value = total * prices.get(coin, 0)
                        total_usdt += usdt_value
                        message += f"{coin}: {total:.8f}"
                        if usdt_value > 0 and coin != 'USDT': message += f" (≈ ${usdt_value:.2f})\n"
                        else: message += "\n"
                message += f"\nTotal Balance: ${total_usdt:.2f}"
                return message
    except Exception as e:
        print(f"Error in fetch_coinex_balance: {str(e)}")
        return f"Error fetching CoinEx balance: {str(e)}"

async def fetch_coinex_positions():
    try:
        timestamp = str(int(time.time() * 1000))
        path = "/v2/futures/position"
        signature = await get_coinex_signature("GET", path, "", timestamp)
        headers = {
            'X-COINEX-KEY': COINEX_API_KEY, 'X-COINEX-SIGN': signature,
            'X-COINEX-TIMESTAMP': timestamp
        }
        url = f"{COINEX_API}{path}"
        async with aiohttp.ClientSession() as session:
            async with session.get(url, headers=headers) as response:
                data = await response.json()
                active_positions = []
                if data.get('code') == 0:
                    for position in data.get('data', []):
                        size = float(position.get('amount', '0'))
                        if size == 0: continue
                        active_positions.append({
                            'symbol': position.get('market'), 'type': "Long" if position.get('side') == 'long' else "Short",
                            'pos_id': position.get('position_id'), 'size': abs(size),
                            'entry': float(position.get('open_price', '0')), 'mark': float(position.get('latest_price', '0')),
                            'liq': float(position.get('liq_price', '0')), 'leverage': float(position.get('leverage', '1')),
                            'pnl': float(position.get('unrealized_pnl', '0')), 'roe': float(position.get('return_rate', '0')) * 100
                        })
                return active_positions
    except Exception as e:
        print(f"Error fetching CoinEx positions: {e}")
        return []

# --- API Call Helpers for Modifications ---

async def binance_set_leverage(symbol: str, leverage: int):
    params_str = f"symbol={symbol}&leverage={leverage}&timestamp={int(time.time() * 1000)}"
    signature = await get_binance_signature(params_str)
    url = f"{BINANCE_FUTURES_API}/fapi/v1/leverage?{params_str}&signature={signature}"
    headers = {'X-MBX-APIKEY': BINANCE_API_KEY}
    async with aiohttp.ClientSession() as session:
        async with session.post(url, headers=headers) as resp:
            return await resp.json()

async def binance_set_tpsl(symbol: str, side: str, price: float, order_type: str):
    params_str = (f"symbol={symbol}&side={side}&type={order_type}&stopPrice={price}"
                  f"&reduceOnly=true&timestamp={int(time.time() * 1000)}")
    signature = await get_binance_signature(params_str)
    url = f"{BINANCE_FUTURES_API}/fapi/v1/order?{params_str}&signature={signature}"
    headers = {'X-MBX-APIKEY': BINANCE_API_KEY}
    async with aiohttp.ClientSession() as session:
        async with session.post(url, headers=headers) as resp:
            return await resp.json()

async def bybit_set_tpsl(symbol: str, tp: str = "", sl: str = ""):
    params = {"category": "linear", "symbol": symbol, "takeProfit": tp, "stopLoss": sl}
    signature, timestamp = await get_bybit_signature(params)
    headers = {
        "X-BAPI-API-KEY": BYBIT_API_KEY, "X-BAPI-SIGN": signature,
        "X-BAPI-TIMESTAMP": timestamp, "Content-Type": "application/json"
    }
    url = f"{BYBIT_API}/v5/position/set-tpsl"
    async with aiohttp.ClientSession() as session:
        async with session.post(url, json=params, headers=headers) as resp:
            return await resp.json()

async def bybit_set_leverage(symbol: str, leverage: str):
    params = {"category": "linear", "symbol": symbol, "buyLeverage": leverage, "sellLeverage": leverage}
    signature, timestamp = await get_bybit_signature(params)
    headers = {
        "X-BAPI-API-KEY": BYBIT_API_KEY, "X-BAPI-SIGN": signature,
        "X-BAPI-TIMESTAMP": timestamp, "Content-Type": "application/json"
    }
    url = f"{BYBIT_API}/v5/position/set-leverage"
    async with aiohttp.ClientSession() as session:
        async with session.post(url, json=params, headers=headers) as resp:
            return await resp.json()
            
async def coinex_set_tpsl(market: str, pos_id: int, tp: str = None, sl: str = None):
    body = {"market": market, "position_id": pos_id}
    if tp: body["take_profit_price"] = tp
    if sl: body["stop_loss_price"] = sl
    
    timestamp = str(int(time.time() * 1000))
    path = "/v2/futures/modify-position-stop"
    signature = await get_coinex_signature("POST", path, body, timestamp)
    headers = {
        'X-COINEX-KEY': COINEX_API_KEY, 'X-COINEX-SIGN': signature,
        'X-COINEX-TIMESTAMP': timestamp, 'Content-Type': 'application/json'
    }
    url = f"{COINEX_API}{path}"
    async with aiohttp.ClientSession() as session:
        async with session.post(url, json=body, headers=headers) as resp:
            return await resp.json()

async def coinex_set_leverage(market: str, leverage: int, pos_type: int):
    body = {"market": market, "leverage": leverage, "position_type": pos_type}
    timestamp = str(int(time.time() * 1000))
    path = "/v2/futures/modify-position-leverage"
    signature = await get_coinex_signature("POST", path, body, timestamp)
    headers = {
        'X-COINEX-KEY': COINEX_API_KEY, 'X-COINEX-SIGN': signature,
        'X-COINEX-TIMESTAMP': timestamp, 'Content-Type': 'application/json'
    }
    url = f"{COINEX_API}{path}"
    async with aiohttp.ClientSession() as session:
        async with session.post(url, json=body, headers=headers) as resp:
            return await resp.json()

# --- Handlers ---
@dp.message_handler(commands=["start"])
async def start_cmd(message: types.Message):
    if message.from_user.id not in ALLOWED_USERS:
        await message.answer("Access denied.")
        return
    await message.answer("Select an option:", reply_markup=main_keyboard)

@dp.message_handler(state='*', commands='cancel')
async def cancel_handler(message: types.Message, state: FSMContext):
    current_state = await state.get_state()
    if current_state is None:
        return
    await state.finish()
    await message.reply('Action cancelled.', reply_markup=types.ReplyKeyboardRemove())

@dp.callback_query_handler(lambda c: c.data == "main_menu")
async def main_menu_handler(callback_query: types.CallbackQuery):
    await callback_query.message.edit_text("Select an option:", reply_markup=main_keyboard)

@dp.callback_query_handler(lambda c: c.data == "binance_menu")
async def binance_menu_handler(callback_query: types.CallbackQuery):
    await callback_query.message.edit_text("Binance Menu", reply_markup=binance_keyboard)

@dp.callback_query_handler(lambda c: c.data == "bybit_menu")
async def bybit_menu_handler(callback_query: types.CallbackQuery):
    await callback_query.message.edit_text("Bybit Menu", reply_markup=bybit_keyboard)

@dp.callback_query_handler(lambda c: c.data == "coinex_menu")
async def coinex_menu_handler(callback_query: types.CallbackQuery):
    await callback_query.message.edit_text("CoinEx Menu", reply_markup=coinex_keyboard)

@dp.callback_query_handler(lambda c: c.data == "get_prices")
async def get_price_handler(callback_query: types.CallbackQuery):
    if callback_query.from_user.id not in ALLOWED_USERS:
        await bot.answer_callback_query(callback_query.id, text="Access denied.", show_alert=True)
        return
    await bot.answer_callback_query(callback_query.id)
    msg = await fetch_prices()
    try: await callback_query.message.edit_text(msg, reply_markup=main_keyboard)
    except MessageNotModified: pass

@dp.callback_query_handler(lambda c: c.data == "binance_balance")
async def get_binance_balance_handler(callback_query: types.CallbackQuery):
    if callback_query.from_user.id not in ALLOWED_USERS:
        await bot.answer_callback_query(callback_query.id, text="Access denied.", show_alert=True)
        return
    await bot.answer_callback_query(callback_query.id)
    msg = await fetch_binance_balance()
    try: await callback_query.message.edit_text(msg, reply_markup=binance_keyboard)
    except MessageNotModified: pass

@dp.callback_query_handler(lambda c: c.data == "bybit_balance")
async def get_bybit_balance_handler(callback_query: types.CallbackQuery):
    if callback_query.from_user.id not in ALLOWED_USERS:
        await bot.answer_callback_query(callback_query.id, text="Access denied.", show_alert=True)
        return
    await bot.answer_callback_query(callback_query.id)
    msg = await fetch_bybit_balance()
    try: await callback_query.message.edit_text(msg, reply_markup=bybit_keyboard)
    except MessageNotModified: pass

@dp.callback_query_handler(lambda c: c.data == "coinex_balance")
async def get_coinex_balance_handler(callback_query: types.CallbackQuery):
    if callback_query.from_user.id not in ALLOWED_USERS:
        await bot.answer_callback_query(callback_query.id, text="Access denied.", show_alert=True)
        return
    await bot.answer_callback_query(callback_query.id)
    msg = await fetch_coinex_balance()
    try: await callback_query.message.edit_text(msg, reply_markup=coinex_keyboard)
    except MessageNotModified: pass

# --- Position List Handlers ---
@dp.callback_query_handler(lambda c: c.data == "binance_positions")
async def get_binance_positions_handler(callback_query: types.CallbackQuery):
    if callback_query.from_user.id not in ALLOWED_USERS:
        await bot.answer_callback_query(callback_query.id, text="Access denied.", show_alert=True)
        return
    positions = await fetch_binance_positions()
    if not positions:
        await callback_query.message.edit_text("No active positions in Binance.", reply_markup=binance_keyboard)
        return
    await callback_query.message.delete()
    for i, pos in enumerate(positions):
        message = (f"{pos['symbol']} ({pos['type']})\n━━━━━━━━━━━━━━━━━━━━━\n"
                   f"Size: {pos['size']:.4f}\nLeverage: {pos['leverage']}x\n"
                   f"Entry Price: ${pos['entry']:,.2f}\nCurrent Price: ${pos['mark']:,.2f}\n"
                   f"Liquidation Price: ${pos['liq']:,.2f}\nPNL: ${pos['pnl']:,.2f} ({pos['roe']:,.2f}%)\n")
        keyboard = await get_position_keyboard('binance', pos['symbol'], i)
        await bot.send_message(callback_query.from_user.id, message, reply_markup=keyboard)

@dp.callback_query_handler(lambda c: c.data == "bybit_positions")
async def get_bybit_positions_handler(callback_query: types.CallbackQuery):
    if callback_query.from_user.id not in ALLOWED_USERS:
        await bot.answer_callback_query(callback_query.id, text="Access Denied", show_alert=True)
        return
    positions = await fetch_bybit_positions()
    if not positions:
        await callback_query.message.edit_text("No active positions in Bybit", reply_markup=bybit_keyboard)
        return
    await callback_query.message.delete()
    for i, pos in enumerate(positions):
        message = (f"{pos['symbol']} ({pos['type']})\n━━━━━━━━━━━━━━━━━━━━━\n"
                   f"Size: {pos['size']:.4f}\nLeverage: {pos['leverage']}x\n"
                   f"Entry: ${pos['entry']:,.2f}\nCurrent: ${pos['mark']:,.2f}\n"
                   f"Liquidation: ${pos['liq']:,.2f}\nPNL: ${pos['pnl']:,.2f} ({pos['roe']:,.2f}%)\n")
        keyboard = await get_position_keyboard('bybit', pos['symbol'], i)
        await bot.send_message(callback_query.from_user.id, message, reply_markup=keyboard)

@dp.callback_query_handler(lambda c: c.data == "coinex_positions")
async def get_coinex_positions_handler(callback_query: types.CallbackQuery):
    if callback_query.from_user.id not in ALLOWED_USERS:
        await bot.answer_callback_query(callback_query.id, text="Access Denied", show_alert=True)
        return
    positions = await fetch_coinex_positions()
    if not positions:
        await callback_query.message.edit_text("No active positions in CoinEx", reply_markup=coinex_keyboard)
        return
    await callback_query.message.delete()
    for i, pos in enumerate(positions):
        message = (f"{pos['symbol']} ({pos['type']})\n━━━━━━━━━━━━━━━━━━━━━\n"
                   f"Size: {pos['size']:.4f}\nLeverage: {pos['leverage']}x\n"
                   f"Entry: ${pos['entry']:,.2f}\nCurrent: ${pos['mark']:,.2f}\n"
                   f"Liquidation: ${pos['liq']:,.2f}\nPNL: ${pos['pnl']:,.2f} ({pos['roe']:,.2f}%)\n")
        keyboard = await get_position_keyboard('coinex', pos['symbol'], i)
        await bot.send_message(callback_query.from_user.id, message, reply_markup=keyboard)

# --- Position Action Handlers ---

# BINANCE
@dp.callback_query_handler(lambda c: c.data.startswith("binance_position_"))
async def binance_position_action_handler(callback_query: types.CallbackQuery, state: FSMContext):
    if callback_query.from_user.id not in ALLOWED_USERS:
        await bot.answer_callback_query(callback_query.id, text="Access denied.", show_alert=True)
        return
    
    parts = callback_query.data.split("_")
    index = int(parts[2])
    action = "_".join(parts[3:])

    positions = await fetch_binance_positions()
    if not positions or index >= len(positions):
        await callback_query.message.edit_text("Position not found.", reply_markup=binance_keyboard)
        return

    pos = positions[index]
    symbol = pos["symbol"]
    side_close = "SELL" if pos["type"].lower() == "long" else "BUY"

    await state.update_data(symbol=symbol, side_close=side_close, exchange='binance')
    
    if action == "set_tp":
        await PositionState.waiting_for_tp.set()
        await callback_query.message.answer(f"Enter Take Profit price for {symbol}: \n(or /cancel)")
    elif action == "set_sl":
        await PositionState.waiting_for_sl.set()
        await callback_query.message.answer(f"Enter Stop Loss price for {symbol}: \n(or /cancel)")
    elif action == "change_leverage":
        await PositionState.waiting_for_leverage.set()
        await callback_query.message.answer(f"Enter new leverage for {symbol} (e.g., 10): \n(or /cancel)")
    else:
        await callback_query.message.answer("This action is not yet implemented.")
    await callback_query.answer()


# BYBIT
@dp.callback_query_handler(lambda c: c.data.startswith("bybit_position_"))
async def bybit_position_action_handler(callback_query: types.CallbackQuery, state: FSMContext):
    if callback_query.from_user.id not in ALLOWED_USERS:
        await bot.answer_callback_query(callback_query.id, text="Access denied.", show_alert=True)
        return

    parts = callback_query.data.split("_")
    index = int(parts[2])
    action = "_".join(parts[3:])

    positions = await fetch_bybit_positions()
    if not positions or index >= len(positions):
        await callback_query.message.edit_text("Position not found.", reply_markup=bybit_keyboard)
        return

    pos = positions[index]
    symbol = pos["symbol"]
    
    if action.startswith("close_"):
        try: pct = int(action.split("_")[1])
        except (ValueError, IndexError): pct = 100
        qty = max(0.0, float(pos["size"]) * (pct / 100.0))
        side_close = "Sell" if pos["type"].lower() == "long" else "Buy"
        resp = await bybit_create_market_close(symbol, side_close, f"{qty:.4f}")
        if resp and resp.get("retCode") == 0:
            await callback_query.message.edit_text(f"✅ Request to close {pct}% of {symbol} sent.", reply_markup=bybit_keyboard)
        else:
            await callback_query.message.edit_text(f"❌ Error closing position: {resp.get('retMsg', 'Unknown')}", reply_markup=bybit_keyboard)
        return

    await state.update_data(symbol=symbol, exchange='bybit')

    if action == "set_tp":
        await PositionState.waiting_for_tp.set()
        await callback_query.message.answer(f"Enter Take Profit price for {symbol}: \n(or /cancel)")
    elif action == "set_sl":
        await PositionState.waiting_for_sl.set()
        await callback_query.message.answer(f"Enter Stop Loss price for {symbol}: \n(or /cancel)")
    elif action == "change_leverage":
        await PositionState.waiting_for_leverage.set()
        await callback_query.message.answer(f"Enter new leverage for {symbol} (e.g., 10): \n(or /cancel)")
    else:
        await callback_query.message.answer("This action is not yet implemented.")
    await callback_query.answer()

# COINEX
@dp.callback_query_handler(lambda c: c.data.startswith("coinex_position_"))
async def coinex_position_action_handler(callback_query: types.CallbackQuery, state: FSMContext):
    if callback_query.from_user.id not in ALLOWED_USERS:
        await bot.answer_callback_query(callback_query.id, text="Access denied.", show_alert=True)
        return

    parts = callback_query.data.split("_")
    index = int(parts[2])
    action = "_".join(parts[3:])

    positions = await fetch_coinex_positions()
    if not positions or index >= len(positions):
        await callback_query.message.edit_text("Position not found.", reply_markup=coinex_keyboard)
        return

    pos = positions[index]
    symbol = pos["symbol"]
    pos_id = pos["pos_id"]
    # For leverage: 1 for isolated, 2 for cross. Assuming isolated margin.
    pos_type_margin = 1 

    await state.update_data(symbol=symbol, pos_id=pos_id, pos_type_margin=pos_type_margin, exchange='coinex')

    if action == "set_tp":
        await PositionState.waiting_for_tp.set()
        await callback_query.message.answer(f"Enter Take Profit price for {symbol}: \n(or /cancel)")
    elif action == "set_sl":
        await PositionState.waiting_for_sl.set()
        await callback_query.message.answer(f"Enter Stop Loss price for {symbol}: \n(or /cancel)")
    elif action == "change_leverage":
        await PositionState.waiting_for_leverage.set()
        await callback_query.message.answer(f"Enter new leverage for {symbol} (e.g., 10): \n(or /cancel)")
    else:
        await callback_query.message.answer("This action is not yet implemented.")
    await callback_query.answer()

# --- State Handlers for User Input ---

@dp.message_handler(state=PositionState.waiting_for_tp)
async def process_tp(message: types.Message, state: FSMContext):
    try:
        price = float(message.text)
        data = await state.get_data()
        symbol = data.get('symbol')
        exchange = data.get('exchange')

        if exchange == 'binance':
            side_close = data.get('side_close')
            resp = await binance_set_tpsl(symbol, side_close, price, "TAKE_PROFIT_MARKET")
            if 'orderId' in resp:
                await message.answer(f"✅ Take Profit for {symbol} set to ${price}.")
            else:
                await message.answer(f"❌ Error setting TP: {resp.get('msg', 'Unknown')}")
        
        elif exchange == 'bybit':
            resp = await bybit_set_tpsl(symbol, tp=str(price))
            if resp.get("retCode") == 0:
                await message.answer(f"✅ Take Profit for {symbol} set to ${price}.")
            else:
                await message.answer(f"❌ Error setting TP: {resp.get('retMsg', 'Unknown')}")
        
        elif exchange == 'coinex':
            pos_id = data.get('pos_id')
            resp = await coinex_set_tpsl(symbol, pos_id, tp=str(price))
            if resp.get("code") == 0:
                 await message.answer(f"✅ Take Profit for {symbol} set to ${price}.")
            else:
                 await message.answer(f"❌ Error setting TP: {resp.get('message', 'Unknown')}")

    except ValueError:
        await message.answer("Invalid price. Please enter a number.")
    finally:
        await state.finish()

@dp.message_handler(state=PositionState.waiting_for_sl)
async def process_sl(message: types.Message, state: FSMContext):
    try:
        price = float(message.text)
        data = await state.get_data()
        symbol = data.get('symbol')
        exchange = data.get('exchange')

        if exchange == 'binance':
            side_close = data.get('side_close')
            resp = await binance_set_tpsl(symbol, side_close, price, "STOP_MARKET")
            if 'orderId' in resp:
                await message.answer(f"✅ Stop Loss for {symbol} set to ${price}.")
            else:
                await message.answer(f"❌ Error setting SL: {resp.get('msg', 'Unknown')}")
        
        elif exchange == 'bybit':
            resp = await bybit_set_tpsl(symbol, sl=str(price))
            if resp.get("retCode") == 0:
                await message.answer(f"✅ Stop Loss for {symbol} set to ${price}.")
            else:
                await message.answer(f"❌ Error setting SL: {resp.get('retMsg', 'Unknown')}")
        
        elif exchange == 'coinex':
            pos_id = data.get('pos_id')
            resp = await coinex_set_tpsl(symbol, pos_id, sl=str(price))
            if resp.get("code") == 0:
                 await message.answer(f"✅ Stop Loss for {symbol} set to ${price}.")
            else:
                 await message.answer(f"❌ Error setting SL: {resp.get('message', 'Unknown')}")

    except ValueError:
        await message.answer("Invalid price. Please enter a number.")
    finally:
        await state.finish()

@dp.message_handler(state=PositionState.waiting_for_leverage)
async def process_leverage(message: types.Message, state: FSMContext):
    try:
        leverage = int(message.text)
        data = await state.get_data()
        symbol = data.get('symbol')
        exchange = data.get('exchange')

        if exchange == 'binance':
            resp = await binance_set_leverage(symbol, leverage)
            if 'leverage' in resp and resp['leverage'] == leverage:
                await message.answer(f"✅ Leverage for {symbol} set to {leverage}x.")
            else:
                await message.answer(f"❌ Error setting leverage: {resp.get('msg', 'Unknown')}")

        elif exchange == 'bybit':
            resp = await bybit_set_leverage(symbol, str(leverage))
            if resp.get("retCode") == 0:
                await message.answer(f"✅ Leverage for {symbol} set to {leverage}x.")
            else:
                await message.answer(f"❌ Error setting leverage: {resp.get('retMsg', 'Unknown')}")
        
        elif exchange == 'coinex':
            pos_type_margin = data.get('pos_type_margin')
            resp = await coinex_set_leverage(symbol, leverage, pos_type_margin)
            if resp.get("code") == 0:
                await message.answer(f"✅ Leverage for {symbol} set to {leverage}x.")
            else:
                await message.answer(f"❌ Error setting leverage: {resp.get('message', 'Unknown')}")

    except ValueError:
        await message.answer("Invalid leverage. Please enter a whole number.")
    finally:
        await state.finish()


# --- Bybit Market Close (already existed) ---
async def bybit_create_market_close(symbol: str, side: str, qty: str):
    params = {
        "category": "linear", "symbol": symbol, "side": side,
        "orderType": "Market", "reduceOnly": True, "qty": qty,
        "timeInForce": "ImmediateOrCancel"
    }
    signature, timestamp = await get_bybit_signature(params)
    headers = {
        "X-BAPI-API-KEY": BYBIT_API_KEY, "X-BAPI-SIGN": signature,
        "X-BAPI-TIMESTAMP": timestamp, "X-BAPI-RECV-WINDOW": "5000",
        "Content-Type": "application/json"
    }
    url = f"{BYBIT_API}/v5/order/create"
    async with aiohttp.ClientSession() as session:
        async with session.post(url, json=params, headers=headers) as resp:
            return await resp.json()

if __name__ == "__main__":
    executor.start_polling(dp, skip_updates=True)
