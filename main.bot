import os
import time
import hmac
import hashlib
import json
import aiohttp
from aiogram import Bot, Dispatcher, types
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.utils import executor
from aiogram.utils.exceptions import MessageNotModified
from dotenv import load_dotenv

load_dotenv()
BOT_TOKEN = os.getenv("BOT_TOKEN")
ALLOWED_USERS = [int(user_id.strip()) for user_id in os.getenv("ALLOWED_USER_ID", "0").split(",")]
BINANCE_API = "https://api.binance.com"
BINANCE_FUTURES_API = "https://fapi.binance.com"
BYBIT_API = "https://api.bybit.com"
WALLEX_API = "https://api.wallex.ir/v1"
BINANCE_API_KEY = os.getenv("BINANCE_API_KEY")
BINANCE_SECRET_KEY = os.getenv("BINANCE_SECRET_KEY")
BYBIT_API_KEY = os.getenv("BYBIT_API_KEY")
BYBIT_SECRET_KEY = os.getenv("BYBIT_SECRET_KEY")
COINEX_API = "https://api.coinex.com"
COINEX_API_KEY = os.getenv("COINEX_API_KEY")
COINEX_SECRET_KEY = os.getenv("COINEX_SECRET_KEY")


bot = Bot(token=BOT_TOKEN)
dp = Dispatcher(bot)

# --- Keyboards ---

# Main Menu
main_keyboard = InlineKeyboardMarkup(row_width=3)
main_keyboard.add(
    InlineKeyboardButton("Rate", callback_data="get_prices"),
    InlineKeyboardButton("Binance", callback_data="binance_menu"),
    InlineKeyboardButton("Bybit", callback_data="bybit_menu"),
    InlineKeyboardButton("CoinEx", callback_data="coinex_menu")
)

# Binance Menu
binance_keyboard = InlineKeyboardMarkup(row_width=2)
binance_keyboard.add(
    InlineKeyboardButton("Balance", callback_data="binance_balance"),
    InlineKeyboardButton("Positions", callback_data="binance_positions")
)
binance_keyboard.add(InlineKeyboardButton("Main Menu", callback_data="main_menu"))

# Bybit Menu
bybit_keyboard = InlineKeyboardMarkup(row_width=2)
bybit_keyboard.add(
    InlineKeyboardButton("Balance", callback_data="bybit_balance"),
    InlineKeyboardButton("Positions", callback_data="bybit_positions")
)
bybit_keyboard.add(InlineKeyboardButton("Main Menu", callback_data="main_menu"))

# CoinEx Menu
coinex_keyboard = InlineKeyboardMarkup(row_width=2)
coinex_keyboard.add(
    InlineKeyboardButton("Balance", callback_data="coinex_balance"),
    InlineKeyboardButton("Positions", callback_data="coinex_positions")
)
coinex_keyboard.add(InlineKeyboardButton("Main Menu", callback_data="main_menu"))


async def get_position_keyboard(exchange, symbol, position_index):
    keyboard = InlineKeyboardMarkup(row_width=2)
    base_data = f"{exchange}_position_{position_index}"

    keyboard.add(
        InlineKeyboardButton("TP", callback_data=f"{base_data}_set_tp"),
        InlineKeyboardButton("SL", callback_data=f"{base_data}_set_sl")
    )
    keyboard.add(
        InlineKeyboardButton("Close 100%", callback_data=f"{base_data}_close_100"),
        InlineKeyboardButton("Close 75%", callback_data=f"{base_data}_close_75")
    )
    keyboard.add(
        InlineKeyboardButton("Close 50%", callback_data=f"{base_data}_close_50"),
        InlineKeyboardButton("Close 25%", callback_data=f"{base_data}_close_25")
    )
    keyboard.add(
        InlineKeyboardButton("Leverage", callback_data=f"{base_data}_change_leverage"),
        InlineKeyboardButton("Size", callback_data=f"{base_data}_change_size")
    )
    keyboard.add(InlineKeyboardButton("Main Menu", callback_data="main_menu"))

    return keyboard


# --- Signature Generators ---

async def get_binance_signature(query_string):
    return hmac.new(
        BINANCE_SECRET_KEY.encode('utf-8'),
        query_string.encode('utf-8'),
        hashlib.sha256
    ).hexdigest()


async def get_bybit_signature(params, recv_window='5000'):
    timestamp = str(int(time.time() * 1000))
    param_str = '&'.join([f'{key}={value}' for key, value in sorted(params.items())])
    to_sign = str(timestamp) + BYBIT_API_KEY + recv_window + param_str

    signature = hmac.new(
        bytes(BYBIT_SECRET_KEY, 'utf-8'),
        bytes(to_sign, 'utf-8'),
        hashlib.sha256
    ).hexdigest()

    return signature, timestamp


async def get_coinex_signature(method, path, timestamp, params_str=""):
    prepared_str = f"{method}{path}{params_str}{timestamp}{COINEX_SECRET_KEY}"
    signature = hashlib.sha256(prepared_str.encode('utf-8')).hexdigest()
    return signature


# --- Price Fetching ---
async def get_all_binance_prices():
    async with aiohttp.ClientSession() as session:
        async with session.get(f"{BINANCE_API}/api/v3/ticker/price") as r:
            data = await r.json()
            prices = {}
            for item in data:
                sym = item.get('symbol', '')
                try:
                    price = float(item.get('price', '0'))
                except (TypeError, ValueError):
                    continue
                prices[sym] = price
            return prices


async def fetch_prices():
    try:
        async with aiohttp.ClientSession() as session:
            # Binance prices
            coins = ["BTCUSDT", "ETHUSDT", "SOLUSDT"]
            binance = {}
            for coin in coins:
                async with session.get(f"{BINANCE_API}/api/v3/ticker/price?symbol={coin}") as r:
                    data = await r.json()
                    binance[coin[:-4]] = float(data["price"])

            # Bybit prices
            bybit = {}
            for coin in coins:
                async with session.get(f"{BYBIT_API}/v5/market/tickers?category=spot&symbol={coin}") as r:
                    data = await r.json()
                    if data.get('result', {}).get('list'):
                        bybit[coin[:-4]] = float(data['result']['list'][0]['lastPrice'])

            # Wallex USDT price
            usdt_tmn = "N/A"
            async with session.get(f"{WALLEX_API}/markets") as r:
                data = await r.json()
                if "result" in data and "symbols" in data["result"]:
                    if "USDTTMN" in data["result"]["symbols"]:
                        market_data = data["result"]["symbols"]["USDTTMN"]
                        if "stats" in market_data and "lastPrice" in market_data["stats"]:
                            price = float(market_data["stats"]["lastPrice"])
                            usdt_tmn = f"{price:,.0f} Toman"

            return (
                "Real-time cryptocurrency rates:\n\n"
                f"USDT (WALLEX): {usdt_tmn}\n\n"
                f"Binance:\n"
                f"BTC: ${binance.get('BTC', 0):,.0f}\n"
                f"ETH: ${binance.get('ETH', 0):,.0f}\n"
                f"SOL: ${binance.get('SOL', 0):,.2f}\n\n"
                f"Bybit:\n"
                f"BTC: ${bybit.get('BTC', 0):,.0f}\n"
                f"ETH: ${bybit.get('ETH', 0):,.0f}\n"
                f"SOL: ${bybit.get('SOL', 0):,.2f}"
            )
    except Exception as e:
        print(f"Error in fetch_prices: {str(e)}")
        return "Error fetching prices"

# --- Balance & Position Fetching (Binance) ---
async def fetch_binance_balance():
    try:
        timestamp = int(time.time() * 1000)
        params = f"timestamp={timestamp}"
        signature = await get_binance_signature(params)
        headers = {'X-MBX-APIKEY': BINANCE_API_KEY}

        async with aiohttp.ClientSession() as session:
            # Spot balance
            spot_url = f"{BINANCE_API}/api/v3/account?{params}&signature={signature}"
            async with session.get(spot_url, headers=headers) as response:
                spot_data = await response.json()

            # Futures balance
            futures_params = f"timestamp={timestamp}"
            futures_signature = await get_binance_signature(futures_params)
            futures_url = f"{BINANCE_FUTURES_API}/fapi/v2/account?{futures_params}&signature={futures_signature}"

            async with session.get(futures_url, headers=headers) as response:
                futures_data = await response.json()

            # Prices
            prices = await get_all_binance_prices()

            message = "Binance Balance:\n\n"
            message += "Spot:\n"
            total_spot_usdt = 0

            # Process spot balance
            if 'balances' in spot_data:
                spot_balances = []
                for asset in spot_data['balances']:
                    symbol = asset['asset']
                    free = float(asset['free'])
                    locked = float(asset['locked'])
                    total = free + locked

                    if total <= 0:
                        continue

                    usdt_value = 0
                    if symbol == 'USDT':
                        usdt_value = total
                    elif f"{symbol}USDT" in prices:
                        usdt_value = total * prices[f"{symbol}USDT"]
                    elif symbol == 'USDC':
                        usdt_value = total

                    if usdt_value >= 0.01:
                        total_spot_usdt += usdt_value
                        spot_balances.append({
                            'symbol': symbol,
                            'amount': total,
                            'usdt': usdt_value
                        })

                spot_balances.sort(key=lambda x: x['usdt'], reverse=True)
                for balance in spot_balances:
                    if balance['symbol'] == 'USDT':
                        message += f"{balance['symbol']}: {balance['amount']:,.2f}\n"
                    else:
                        message += f"{balance['symbol']}: {balance['amount']:,.8f} (≈ ${balance['usdt']:,.2f})\n"

            message += f"\nTotal Spot: ${total_spot_usdt:,.2f}\n"

            # Process futures balance
            message += "\nFutures:\n"
            total_futures_usdt = 0

            if 'assets' in futures_data:
                futures_balances = []
                for asset in futures_data['assets']:
                    symbol = asset['asset']
                    wallet_balance = float(asset['walletBalance'])

                    if wallet_balance > 0:
                        if symbol == 'USDT':
                            futures_balances.append({
                                'symbol': symbol,
                                'amount': wallet_balance,
                                'usdt': wallet_balance
                            })
                            total_futures_usdt += wallet_balance

                futures_balances.sort(key=lambda x: x['usdt'], reverse=True)
                for balance in futures_balances:
                    message += f"{balance['symbol']}: ${balance['amount']:,.2f}\n"

            message += f"\nTotal Futures: ${total_futures_usdt:,.2f}\n"
            message += f"\nTotal: ${(total_spot_usdt + total_futures_usdt):,.2f}"

            return message

    except Exception as e:
        print(f"Error in fetch_binance_balance: {str(e)}")
        return "Error fetching Binance balance"


async def fetch_binance_positions():
    try:
        timestamp = int(time.time() * 1000)
        params = f"timestamp={timestamp}"
        signature = await get_binance_signature(params)
        headers = {'X-MBX-APIKEY': BINANCE_API_KEY}

        async with aiohttp.ClientSession() as session:
            positions_url = f"{BINANCE_FUTURES_API}/fapi/v2/positionRisk?{params}&signature={signature}"
            async with session.get(positions_url, headers=headers) as response:
                positions_data = await response.json()

            active_positions = []
            for position in positions_data:
                size = float(position['positionAmt'])
                if size == 0:
                    continue

                entry_price = float(position['entryPrice'])
                mark_price = float(position['markPrice'])
                leverage = float(position['leverage'])
                liquidation_price = float(position['liquidationPrice'])
                unreal_pnl = float(position['unRealizedProfit'])

                position_type = "Long" if size > 0 else "Short"
                roe = (mark_price - entry_price) / entry_price * 100 * leverage if size > 0 else (entry_price - mark_price) / entry_price * 100 * leverage

                active_positions.append({
                    'symbol': position['symbol'],
                    'type': position_type,
                    'size': abs(size),
                    'entry': entry_price,
                    'mark': mark_price,
                    'liq': liquidation_price,
                    'leverage': leverage,
                    'pnl': unreal_pnl,
                    'roe': roe
                })

            return active_positions
    except Exception as e:
        print(f"Error in fetch_binance_positions: {str(e)}")
        return []

# --- Balance & Position Fetching (Bybit) ---

async def fetch_bybit_balance():
    try:
        params = {'accountType': 'UNIFIED'}
        signature, timestamp = await get_bybit_signature(params)
        headers = {
            'X-BAPI-API-KEY': BYBIT_API_KEY,
            'X-BAPI-SIGN': signature,
            'X-BAPI-TIMESTAMP': timestamp,
            'X-BAPI-RECV-WINDOW': '5000'
        }
        url = f"{BYBIT_API}/v5/account/wallet-balance"

        async with aiohttp.ClientSession() as session:
            async with session.get(url, params=params, headers=headers) as response:
                data = await response.json()
                message = "Bybit Balance:\n\n"

                if data.get('retCode') == 0:
                    balances = data.get('result', {}).get('list', [])
                    if balances:
                        balance = balances[0]
                        total_equity = float(balance.get('totalEquity', '0'))
                        wallet_balance = float(balance.get('totalWalletBalance', '0'))

                        message += f"Total Equity: {total_equity:,.2f} USDT\n"
                        message += f"Wallet Balance: {wallet_balance:,.2f} USDT\n\n"

                        coins = balance.get('coin', [])
                        if coins:
                            message += "Details:\n"
                            for coin in coins:
                                if float(coin.get('walletBalance', '0')) > 0:
                                    coin_name = coin.get('coin', '')
                                    coin_balance = float(coin.get('walletBalance', '0'))
                                    coin_value = float(coin.get('usdValue', '0'))
                                    message += f"{coin_name}: {coin_balance:,.8f}"
                                    if coin_name != 'USDT':
                                        message += f" (≈ ${coin_value:,.2f})\n"
                                    else:
                                        message += "\n"
                else:
                    error_msg = data.get('retMsg', 'Unknown error')
                    message += f"Error: {error_msg}"

                return message

    except Exception as e:
        print(f"Bybit Balance Error: {str(e)}")
        return "Error fetching Bybit balance"


async def fetch_bybit_positions():
    try:
        params = {
            'category': 'linear',
            'settleCoin': 'USDT'
        }
        signature, timestamp = await get_bybit_signature(params)
        headers = {
            'X-BAPI-API-KEY': BYBIT_API_KEY,
            'X-BAPI-SIGN': signature,
            'X-BAPI-TIMESTAMP': timestamp,
            'X-BAPI-RECV-WINDOW': '5000'
        }
        url = f"{BYBIT_API}/v5/position/list"

        async with aiohttp.ClientSession() as session:
            async with session.get(url, params=params, headers=headers) as response:
                data = await response.json()
                active_positions = []

                if data.get('retCode') == 0:
                    positions = data.get('result', {}).get('list', [])
                    for position in positions:
                        size = float(position.get('size', '0'))
                        if size == 0:
                            continue

                        entry_price = float(position.get('avgPrice', '0'))
                        mark_price = float(position.get('markPrice', '0'))
                        leverage = float(position.get('leverage', '1'))
                        liq_price = float(position.get('liqPrice', '0'))
                        unrealized_pnl = float(position.get('unrealisedPnl', '0'))
                        position_value = float(position.get('positionValue', '0'))
                        side = position.get('side', '')
                        position_type = "Long" if side == "Buy" else "Short"

                        if position_value != 0:
                            roe = (unrealized_pnl / position_value) * 100
                        else:
                            roe = 0

                        active_positions.append({
                            'symbol': position.get('symbol', ''),
                            'type': position_type,
                            'size': size,
                            'entry': entry_price,
                            'mark': mark_price,
                            'liq': liq_price,
                            'leverage': leverage,
                            'pnl': unrealized_pnl,
                            'roe': roe
                        })

                return active_positions

    except Exception as e:
        print(f"Bybit Positions Error: {str(e)}")
        return []

# --- Balance & Position Fetching (CoinEx) ---
async def fetch_coinex_balance():
    try:
        timestamp = str(int(time.time() * 1000))
        path = "/v2/assets/spot/balance"
        signature = await get_coinex_signature("GET", path, timestamp)

        headers = {
            'X-COINEX-KEY': COINEX_API_KEY,
            'X-COINEX-SIGN': signature,
            'X-COINEX-TIMESTAMP': timestamp,
            'Content-Type': 'application/json'
        }
        url = f"{COINEX_API}{path}"

        async with aiohttp.ClientSession() as session:
            # Get balances
            async with session.get(url, headers=headers) as response:
                data = await response.json()

                if data.get('code') != 0:
                    return f"Error: {data.get('message', 'Unknown error')}"

                message = "CoinEx Balance:\n\n"
                total_usdt = 0

                # Get prices
                try:
                    ticker_url = f"{COINEX_API}/v2/spot/market/ticker/all"
                    async with session.get(ticker_url) as ticker_response:
                        ticker_data = await ticker_response.json()
                        if ticker_data.get('code') == 0:
                            prices = {}
                            for market, ticker in ticker_data.get('data', {}).items():
                                if market.endswith('USDT'):
                                    coin = market[:-4]
                                    prices[coin] = float(ticker['last'])
                        else:
                            prices = {}
                except Exception as e:
                    print(f"Error fetching CoinEx prices: {e}")
                    prices = {}

                # Process balances
                balances = data.get('data', [])
                for balance in balances:
                    coin = balance.get('ccy')
                    available = float(balance.get('available', '0'))
                    frozen = float(balance.get('frozen', '0'))
                    total = available + frozen

                    if total > 0:
                        usdt_value = 0
                        if coin == 'USDT':
                            usdt_value = total
                        elif coin in prices:
                            usdt_value = total * prices.get(coin, 0)

                        total_usdt += usdt_value

                        message += f"{coin}: {total:.8f}"
                        if usdt_value > 0:
                            message += f" (≈ ${usdt_value:.2f})\n"
                        else:
                            message += "\n"

                message += f"\nTotal Balance: ${total_usdt:.2f}"
                return message

    except Exception as e:
        print(f"Error in fetch_coinex_balance: {str(e)}")
        return f"Error fetching CoinEx balance: {str(e)}"

async def fetch_coinex_positions():
    try:
        timestamp = str(int(time.time() * 1000))
        path = "/v2/futures/position"
        signature = await get_coinex_signature("GET", path, timestamp)
        headers = {
            'X-COINEX-KEY': COINEX_API_KEY,
            'X-COINEX-SIGN': signature,
            'X-COINEX-TIMESTAMP': timestamp
        }

        url = f"{COINEX_API}{path}"
        async with aiohttp.ClientSession() as session:
            async with session.get(url, headers=headers) as response:
                data = await response.json()

                active_positions = []

                if data.get('code') == 0:
                    positions = data.get('data', [])
                    for position in positions:
                        size = float(position.get('amount', '0'))
                        if size == 0:
                            continue

                        entry_price = float(position.get('open_price', '0'))
                        mark_price = float(position.get('latest_price', '0'))
                        leverage = float(position.get('leverage', '1'))
                        liq_price = float(position.get('liq_price', '0'))
                        unrealized_pnl = float(position.get('unrealized_pnl', '0'))

                        position_type = "Long" if position.get('side') == 'long' else "Short"

                        active_positions.append({
                            'symbol': position.get('market'),
                            'type': position_type,
                            'size': abs(size),
                            'entry': entry_price,
                            'mark': mark_price,
                            'liq': liq_price,
                            'leverage': leverage,
                            'pnl': unrealized_pnl,
                            'roe': float(position.get('return_rate', '0')) * 100
                        })

                return active_positions

    except Exception as e:
        print(f"Error fetching CoinEx positions: {e}")
        return []

# --- Handlers ---
@dp.message_handler(commands=["start"])
async def start_cmd(message: types.Message):
    if message.from_user.id not in ALLOWED_USERS:
        await message.answer("Access denied.")
        return
    await message.answer("Select an option:", reply_markup=main_keyboard)


@dp.callback_query_handler(lambda c: c.data == "main_menu")
async def main_menu_handler(callback_query: types.CallbackQuery):
    await callback_query.message.edit_text(
        "Select an option:",
        reply_markup=main_keyboard
    )


@dp.callback_query_handler(lambda c: c.data == "binance_menu")
async def binance_menu_handler(callback_query: types.CallbackQuery):
    await callback_query.message.edit_text(
        "Binance Menu",
        reply_markup=binance_keyboard
    )


@dp.callback_query_handler(lambda c: c.data == "bybit_menu")
async def bybit_menu_handler(callback_query: types.CallbackQuery):
    await callback_query.message.edit_text(
        "Bybit Menu",
        reply_markup=bybit_keyboard
    )


@dp.callback_query_handler(lambda c: c.data == "coinex_menu")
async def coinex_menu_handler(callback_query: types.CallbackQuery):
    await callback_query.message.edit_text(
        "CoinEx Menu",
        reply_markup=coinex_keyboard
    )


@dp.callback_query_handler(lambda c: c.data == "get_prices")
async def get_price_handler(callback_query: types.CallbackQuery):
    if callback_query.from_user.id not in ALLOWED_USERS:
        await bot.answer_callback_query(callback_query.id, text="Access denied.", show_alert=True)
        return
    await bot.answer_callback_query(callback_query.id)
    msg = await fetch_prices()
    try:
        await callback_query.message.edit_text(
            msg,
            reply_markup=main_keyboard
        )
    except MessageNotModified:
        pass


@dp.callback_query_handler(lambda c: c.data == "binance_balance")
async def get_binance_balance_handler(callback_query: types.CallbackQuery):
    if callback_query.from_user.id not in ALLOWED_USERS:
        await bot.answer_callback_query(callback_query.id, text="Access denied.", show_alert=True)
        return
    await bot.answer_callback_query(callback_query.id)
    msg = await fetch_binance_balance()
    try:
        await callback_query.message.edit_text(
            msg,
            reply_markup=binance_keyboard
        )
    except MessageNotModified:
        pass


@dp.callback_query_handler(lambda c: c.data == "bybit_balance")
async def get_bybit_balance_handler(callback_query: types.CallbackQuery):
    if callback_query.from_user.id not in ALLOWED_USERS:
        await bot.answer_callback_query(callback_query.id, text="Access denied.", show_alert=True)
        return
    await bot.answer_callback_query(callback_query.id)
    msg = await fetch_bybit_balance()
    try:
        await callback_query.message.edit_text(
            msg,
            reply_markup=bybit_keyboard
        )
    except MessageNotModified:
        pass

@dp.callback_query_handler(lambda c: c.data == "coinex_balance")
async def get_coinex_balance_handler(callback_query: types.CallbackQuery):
    if callback_query.from_user.id not in ALLOWED_USERS:
        await bot.answer_callback_query(callback_query.id, text="Access denied.", show_alert=True)
        return
    await bot.answer_callback_query(callback_query.id)
    msg = await fetch_coinex_balance()
    try:
        await callback_query.message.edit_text(msg, reply_markup=coinex_keyboard)
    except MessageNotModified:
        pass


@dp.callback_query_handler(lambda c: c.data == "binance_positions")
async def get_binance_positions_handler(callback_query: types.CallbackQuery):
    if callback_query.from_user.id not in ALLOWED_USERS:
        await bot.answer_callback_query(callback_query.id, text="Access denied.", show_alert=True)
        return

    positions = await fetch_binance_positions()

    if not positions:
        await callback_query.message.edit_text(
            "No active positions in Binance.",
            reply_markup=binance_keyboard
        )
        return

    await callback_query.message.delete()

    for i, pos in enumerate(positions):
        message = (
            f"{pos['symbol']} ({pos['type']})\n"
            f"━━━━━━━━━━━━━━━━━━━━━\n"
            f"Size: {pos['size']:.4f}\n"
            f"Leverage: {pos['leverage']}x\n"
            f"Entry Price: ${pos['entry']:,.2f}\n"
            f"Current Price: ${pos['mark']:,.2f}\n"
            f"Liquidation Price: ${pos['liq']:,.2f}\n"
            f"PNL: ${pos['pnl']:,.2f} ({pos['roe']:,.2f}%)\n"
        )

        keyboard = await get_position_keyboard('binance', pos['symbol'], i)
        await bot.send_message(
            callback_query.from_user.id,
            message,
            reply_markup=keyboard
        )


@dp.callback_query_handler(lambda c: c.data == "bybit_positions")
async def get_bybit_positions_handler(callback_query: types.CallbackQuery):
    if callback_query.from_user.id not in ALLOWED_USERS:
        await bot.answer_callback_query(callback_query.id, text="Access Denied", show_alert=True)
        return

    positions = await fetch_bybit_positions()

    if not positions:
        await callback_query.message.edit_text(
            "No active positions in Bybit",
            reply_markup=bybit_keyboard
        )
        return

    await callback_query.message.delete()

    for i, pos in enumerate(positions):
        message = (
            f"{pos['symbol']} ({pos['type']})\n"
            f"━━━━━━━━━━━━━━━━━━━━━\n"
            f"Size: {pos['size']:.4f}\n"
            f"Leverage: {pos['leverage']}x\n"
            f"Entry: ${pos['entry']:,.2f}\n"
            f"Current: ${pos['mark']:,.2f}\n"
            f"Liquidation: ${pos['liq']:,.2f}\n"
            f"PNL: ${pos['pnl']:,.2f} ({pos['roe']:,.2f}%)\n"
        )

        keyboard = await get_position_keyboard('bybit', pos['symbol'], i)
        await bot.send_message(
            callback_query.from_user.id,
            message,
            reply_markup=keyboard
        )


@dp.callback_query_handler(lambda c: c.data == "coinex_positions")
async def get_coinex_positions_handler(callback_query: types.CallbackQuery):
    if callback_query.from_user.id not in ALLOWED_USERS:
        await bot.answer_callback_query(callback_query.id, text="Access Denied", show_alert=True)
        return

    positions = await fetch_coinex_positions()

    if not positions:
        await callback_query.message.edit_text(
            "No active positions in CoinEx",
            reply_markup=coinex_keyboard
        )
        return

    await callback_query.message.delete()

    for i, pos in enumerate(positions):
        message = (
            f"{pos['symbol']} ({pos['type']})\n"
            f"━━━━━━━━━━━━━━━━━━━━━\n"
            f"Size: {pos['size']:.4f}\n"
            f"Leverage: {pos['leverage']}x\n"
            f"Entry: ${pos['entry']:,.2f}\n"
            f"Current: ${pos['mark']:,.2f}\n"
            f"Liquidation: ${pos['liq']:,.2f}\n"
            f"PNL: ${pos['pnl']:,.2f} ({pos['roe']:,.2f}%)\n"
        )

        keyboard = await get_position_keyboard('coinex', pos['symbol'], i)
        await bot.send_message(
            callback_query.from_user.id,
            message,
            reply_markup=keyboard
        )

# --- Position Actions ---
async def bybit_create_market_close(symbol: str, side: str, qty: float):
    """
    Create a reduce-only market order on Bybit to close a percentage of a position.
    """
    params = {
        "category": "linear",
        "symbol": symbol,
        "side": side,
        "orderType": "Market",
        "reduceOnly": True,
        "qty": f"{qty}",
        "timeInForce": "ImmediateOrCancel"
    }
    signature, timestamp = await get_bybit_signature(params)
    headers = {
        "X-BAPI-API-KEY": BYBIT_API_KEY,
        "X-BAPI-SIGN": signature,
        "X-BAPI-TIMESTAMP": timestamp,
        "X-BAPI-RECV-WINDOW": "5000",
        "Content-Type": "application/json"
    }
    url = f"{BYBIT_API}/v5/order/create"
    async with aiohttp.ClientSession() as session:
        async with session.post(url, json=params, headers=headers) as resp:
            data = await resp.json()
            return data


@dp.callback_query_handler(lambda c: c.data.startswith("bybit_position_"))
async def bybit_position_action_handler(callback_query: types.CallbackQuery):
    if callback_query.from_user.id not in ALLOWED_USERS:
        await bot.answer_callback_query(callback_query.id, text="Access denied.", show_alert=True)
        return
    await bot.answer_callback_query(callback_query.id)

    parts = callback_query.data.split("_")
    if len(parts) < 4:
        await bot.answer_callback_query(callback_query.id, text="Invalid data", show_alert=True)
        return

    try:
        index = int(parts[2])
    except ValueError:
        await bot.answer_callback_query(callback_query.id,
                                        text="Invalid position ID", show_alert=True)
        return

    action = "_".join(parts[3:])

    positions = await fetch_bybit_positions()
    if not positions or index >= len(positions):
        await callback_query.message.edit_text("Position not found.", reply_markup=bybit_keyboard)
        return

    pos = positions[index]
    symbol = pos["symbol"]
    size = float(pos["size"])
    side_open = "Buy" if pos["type"].lower() == "long" else "Sell"
    side_close = "Sell" if side_open == "Buy" else "Buy"

    if action.startswith("close_"):
        try:
            pct = int(action.split("_")[1])
        except (ValueError, IndexError):
            pct = 100
        qty = max(0.0, size * (pct / 100.0))
        qty = float(f"{qty:.4f}")
        if qty <= 0:
            await callback_query.message.edit_text("Not enough volume to close.", reply_markup=bybit_keyboard)
            return

        resp = await bybit_create_market_close(symbol, side_close, qty)
        ok = bool(resp and resp.get("retCode") == 0)
        if ok:
            await callback_query.message.edit_text(
                f"✅ Request to close {pct}% of {symbol} sent.",
                reply_markup=bybit_keyboard
            )
        else:
            err = resp.get("retMsg") if isinstance(resp, dict) else "Unknown"
            await callback_query.message.edit_text(
                f"❌ Error closing position: {err}",
                reply_markup=bybit_keyboard
            )
        return

    await callback_query.message.edit_text("This option will be added soon.", reply_markup=bybit_keyboard)


if __name__ == "__main__":
    executor.start_polling(dp, skip_updates=True)
