import os
import asyncio
from dotenv import load_dotenv
import ccxt.async_support as ccxt
import aiohttp
from aiogram import Bot, Dispatcher, types
from aiogram.contrib.fsm_storage.memory import MemoryStorage
from aiogram.dispatcher import FSMContext
from aiogram.dispatcher.filters.state import State, StatesGroup
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.utils import executor

# --- Load Environment Variables ---
load_dotenv()
BOT_TOKEN = os.getenv("BOT_TOKEN")
ALLOWED_USERS = [int(user_id.strip()) for user_id in os.getenv("ALLOWED_USER_ID", "").split(",") if user_id]
WALLEX_API = "https://api.wallex.ir/v1"

# --- Exchange API Keys ---
EXCHANGES = {
    "binance": {"apiKey": os.getenv("BINANCE_API_KEY"), "secret": os.getenv("BINANCE_SECRET_KEY")},
    "bybit": {"apiKey": os.getenv("BYBIT_API_KEY"), "secret": os.getenv("BYBIT_SECRET_KEY")},
    "coinex": {"apiKey": os.getenv("COINEX_API_KEY"), "secret": os.getenv("COINEX_SECRET_KEY")},
}

# --- Bot Initialization (Using MarkdownV2) ---
storage = MemoryStorage()
bot = Bot(token=BOT_TOKEN, parse_mode=types.ParseMode.MARKDOWN_V2)
dp = Dispatcher(bot, storage=storage)

# --- Helper Function for MarkdownV2 ---
def escape_markdown(text: any) -> str:
    """Escapes special characters for Telegram MarkdownV2."""
    escape_chars = r'_*[]()~`>#+-=|{}.!'
    return str(text).translate(str.maketrans({char: f'\\{char}' for char in escape_chars}))

# --- FSM States ---
class PositionState(StatesGroup):
    pass # Can be expanded later

# --- Keyboard Layouts ---
def get_main_menu():
    keyboard = InlineKeyboardMarkup(row_width=2)
    keyboard.add(
        InlineKeyboardButton("ğŸ¦ ØµØ±Ø§ÙÛŒâ€ŒÙ‡Ø§", callback_data="menu_exchanges"),
        InlineKeyboardButton("ğŸ“ˆ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø¨Ø§Ø²Ø§Ø±", callback_data="menu_market_info")
    )
    return keyboard

def get_exchanges_menu():
    keyboard = InlineKeyboardMarkup(row_width=2)
    keyboard.add(
        InlineKeyboardButton("Binance", callback_data="exchange_binance"),
        InlineKeyboardButton("Bybit", callback_data="exchange_bybit"),
        InlineKeyboardButton("CoinEx", callback_data="exchange_coinex")
    )
    keyboard.add(InlineKeyboardButton("â¬…ï¸ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="main_menu"))
    return keyboard

def get_exchange_actions_menu(exchange_name: str):
    keyboard = InlineKeyboardMarkup(row_width=2)
    keyboard.add(
        InlineKeyboardButton("ğŸ’° Ù…ÙˆØ¬ÙˆØ¯ÛŒ", callback_data=f"balance_{exchange_name}"),
        InlineKeyboardButton("ğŸ“Š Ù¾ÙˆØ²ÛŒØ´Ù†â€ŒÙ‡Ø§", callback_data=f"positions_{exchange_name}")
    )
    keyboard.add(InlineKeyboardButton("â¬…ï¸ Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ ØµØ±Ø§ÙÛŒâ€ŒÙ‡Ø§", callback_data="menu_exchanges"))
    return keyboard

# --- API Fetching Functions ---
async def fetch_wallex_usdt_price():
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(f"{WALLEX_API}/markets") as response:
                if response.status != 200: return "N/A"
                data = await response.json()
                price = data.get("result", {}).get("symbols", {}).get("USDTTMN", {}).get("stats", {}).get("lastPrice")
                return f"{float(price):,.0f} ØªÙˆÙ…Ø§Ù†" if price else "N/A"
    except Exception:
        return "N/A"

async def fetch_exchange_prices(exchange_name: str, symbols: list):
    prices = {}
    exchange = await get_exchange(exchange_name)
    if not exchange: return prices
    try:
        tickers = await exchange.fetch_tickers(symbols)
        for symbol, ticker_data in tickers.items():
            prices[symbol.split('/')[0]] = ticker_data['last']
    except Exception as e:
        print(f"Could not fetch prices from {exchange_name}: {e}")
    finally:
        if exchange: await exchange.close()
    return prices

async def get_exchange(exchange_name: str):
    if exchange_name not in EXCHANGES: return None
    config = EXCHANGES[exchange_name].copy()
    exchange_class = getattr(ccxt, exchange_name)
    return exchange_class(config)

async def format_balance_message(balance_data, tickers):
    """Helper to format a specific balance section (e.g., Spot or Futures)."""
    message = ""
    total_usdt_value = 0
    balances_to_display = []

    for currency, amount in balance_data['total'].items():
        if amount > 0:
            usdt_value = 0
            if currency == 'USDT':
                usdt_value = amount
            elif f"{currency}/USDT" in tickers:
                usdt_value = amount * tickers[f"{currency}/USDT"]['last']
            
            if usdt_value > 1:
                balances_to_display.append({'coin': currency, 'total': amount, 'usdt': usdt_value})
                total_usdt_value += usdt_value
    
    balances_to_display.sort(key=lambda x: x['usdt'], reverse=True)

    for bal in balances_to_display:
        coin = escape_markdown(bal['coin'])
        total = escape_markdown(f"{bal['total']:.6f}".rstrip('0').rstrip('.'))
        usdt_val = escape_markdown(f"{bal['usdt']:,.2f}")
        message += f"*{coin}*: `{total}` \\(â‰ˆ ${usdt_val}\\)\n"
        
    return message, total_usdt_value

async def fetch_unified_balance(exchange_name: str):
    exchange = await get_exchange(exchange_name)
    if not exchange: return f"ØµØ±Ø§ÙÛŒ '{exchange_name}' Ù¾ÛŒÚ©Ø±Ø¨Ù†Ø¯ÛŒ Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª\\."

    try:
        message = f"ğŸ’° *Ù…ÙˆØ¬ÙˆØ¯ÛŒ ØµØ±Ø§ÙÛŒ {exchange.name}*\n\n"
        grand_total_usdt = 0
        
        # Fetch all tickers once
        tickers = await exchange.fetch_tickers()

        if exchange_name == 'binance':
            # --- Binance: Fetch Spot and Futures separately ---
            # Fetch Spot Balance
            spot_balance = await exchange.fetch_balance()
            spot_message, spot_total = await format_balance_message(spot_balance, tickers)
            if spot_total > 1:
                grand_total_usdt += spot_total
                message += "*Spot*\n" + spot_message
                message += f"__Total Spot__: `${escape_markdown(f'{spot_total:,.2f}')}`\n\n"

            # Fetch Futures Balance
            futures_balance = await exchange.fetch_balance(params={'type': 'future'})
            futures_message, futures_total = await format_balance_message(futures_balance, tickers)
            if futures_total > 1:
                grand_total_usdt += futures_total
                message += "*Futures*\n" + futures_message
                message += f"__Total Futures__: `${escape_markdown(f'{futures_total:,.2f}')}`\n\n"

        else:
            # --- For Bybit, CoinEx, and others ---
            balance = await exchange.fetch_balance()
            balance_message, total_usdt = await format_balance_message(balance, tickers)
            grand_total_usdt += total_usdt
            if total_usdt > 1:
                message += balance_message

        if grand_total_usdt == 0:
            return f"Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ù‚Ø§Ø¨Ù„ ØªÙˆØ¬Ù‡ÛŒ Ø¯Ø± ØµØ±Ø§ÙÛŒ {exchange.name} ÛŒØ§ÙØª Ù†Ø´Ø¯\\. Ù„Ø·ÙØ§Ù‹ Ø¯Ø³ØªØ±Ø³ÛŒ Ú©Ù„ÛŒØ¯ API Ø®ÙˆØ¯ Ø±Ø§ Ø¨Ø±Ø±Ø³ÛŒ Ú©Ù†ÛŒØ¯\\."

        message += f"\n*Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ú©Ù„ Ú©Ù„*: `${escape_markdown(f'{grand_total_usdt:,.2f}')}`"
        return message

    except ccxt.AuthenticationError:
        return f"âŒ *Ø®Ø·Ø§ÛŒ Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª* Ø¨Ø±Ø§ÛŒ {exchange.name}\\!\n\nÙ„Ø·ÙØ§Ù‹ Ù…Ø·Ù…Ø¦Ù† Ø´ÙˆÛŒØ¯ Ú©Ù„ÛŒØ¯Ù‡Ø§ÛŒ API Ø´Ù…Ø§ ØµØ­ÛŒØ­ Ùˆ Ù…Ø¹ØªØ¨Ø± Ù‡Ø³ØªÙ†Ø¯\\."
    except Exception as e:
        return f"Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù…ÙˆØ¬ÙˆØ¯ÛŒ {exchange.name}: {escape_markdown(str(e))}"
    finally:
        if exchange: await exchange.close()


# --- Telegram Handlers ---
@dp.message_handler(commands=["start"])
async def start_cmd(message: types.Message):
    if message.from_user.id not in ALLOWED_USERS:
        return await message.answer("âŒ Ø´Ù…Ø§ Ø§Ø¬Ø§Ø²Ù‡ Ø¯Ø³ØªØ±Ø³ÛŒ Ø¨Ù‡ Ø§ÛŒÙ† Ø±Ø¨Ø§Øª Ø±Ø§ Ù†Ø¯Ø§Ø±ÛŒØ¯\\.")
    await message.answer("Ø³Ù„Ø§Ù…\\! Ø¨Ù‡ Ø±Ø¨Ø§Øª Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ø±ÛŒÙ¾ØªÙˆ Ø®ÙˆØ¯ Ø®ÙˆØ´ Ø¢Ù…Ø¯ÛŒØ¯\\.", reply_markup=get_main_menu())

@dp.callback_query_handler(lambda c: c.data == "main_menu", state='*')
async def main_menu_handler(query: types.CallbackQuery, state: FSMContext):
    await state.finish()
    await query.message.edit_text("Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ:", reply_markup=get_main_menu())

@dp.callback_query_handler(lambda c: c.data == "menu_exchanges")
async def exchanges_menu_handler(query: types.CallbackQuery):
    await query.message.edit_text("Ù„Ø·ÙØ§Ù‹ ØµØ±Ø§ÙÛŒ Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø± Ø®ÙˆØ¯ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯:", reply_markup=get_exchanges_menu())

@dp.callback_query_handler(lambda c: c.data == "menu_market_info")
async def market_info_handler(query: types.CallbackQuery):
    await query.answer("Ø¯Ø± Ø­Ø§Ù„ Ø¯Ø±ÛŒØ§ÙØª Ù‚ÛŒÙ…Øªâ€ŒÙ‡Ø§...")
    
    coins_to_fetch = ['BTC/USDT', 'ETH/USDT', 'SOL/USDT']
    
    wallex_task = fetch_wallex_usdt_price()
    binance_task = fetch_exchange_prices('binance', coins_to_fetch)
    bybit_task = fetch_exchange_prices('bybit', coins_to_fetch)
    
    usdt_price, binance_prices, bybit_prices = await asyncio.gather(
        wallex_task, binance_task, bybit_task
    )

    message = f"ğŸ“ˆ *Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø¨Ø§Ø²Ø§Ø±*\n\n"
    message += f"ğŸ‡®ğŸ‡· *Ù‚ÛŒÙ…Øª ØªØªØ± \\(ÙˆØ§Ù„Ú©Ø³\\)*: `{escape_markdown(usdt_price)}`\n"
    message += "â€”\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\n\n"

    message += "*Binance*\n"
    for coin, price in binance_prices.items():
        message += f"*{coin}*: `${escape_markdown(f'{price:,.2f}')}`\n"
    message += "\n"

    message += "*Bybit*\n"
    for coin, price in bybit_prices.items():
        message += f"*{coin}*: `${escape_markdown(f'{price:,.2f}')}`\n"

    await query.message.edit_text(message, reply_markup=get_main_menu())


@dp.callback_query_handler(lambda c: c.data.startswith("exchange_"))
async def exchange_actions_handler(query: types.CallbackQuery):
    exchange_name = query.data.split("_")[1]
    await query.message.edit_text(f"ØµØ±Ø§ÙÛŒ *{escape_markdown(exchange_name.title())}* Ø§Ù†ØªØ®Ø§Ø¨ Ø´Ø¯\\. Ú†Ù‡ Ú©Ø§Ø±ÛŒ Ù…ÛŒâ€ŒØ®ÙˆØ§Ù‡ÛŒØ¯ Ø§Ù†Ø¬Ø§Ù… Ø¯Ù‡ÛŒØ¯ØŸ", reply_markup=get_exchange_actions_menu(exchange_name))

@dp.callback_query_handler(lambda c: c.data.startswith("balance_"))
async def get_balance_handler(query: types.CallbackQuery):
    exchange_name = query.data.split("_")[1]
    await query.answer(f"Ø¯Ø± Ø­Ø§Ù„ Ø¯Ø±ÛŒØ§ÙØª Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ø§Ø² {exchange_name}...")
    msg = await fetch_unified_balance(exchange_name)
    await query.message.edit_text(msg, reply_markup=get_exchange_actions_menu(exchange_name))

@dp.callback_query_handler(lambda c: c.data.startswith("positions_"))
async def get_positions_handler(query: types.CallbackQuery):
    await query.answer("Ø§ÛŒÙ† Ù‚Ø§Ø¨Ù„ÛŒØª Ø¨Ù‡ Ø²ÙˆØ¯ÛŒ Ø§Ø¶Ø§ÙÙ‡ Ø®ÙˆØ§Ù‡Ø¯ Ø´Ø¯!", show_alert=True)

# --- Main Execution ---
if __name__ == "__main__":
    if not BOT_TOKEN or not ALLOWED_USERS:
        print("âŒ ERROR: BOT_TOKEN and ALLOWED_USER_ID must be set in the .env file.")
    else:
        print("âœ… Bot is running...")
        executor.start_polling(dp, skip_updates=True)
