import os
import asyncio
from dotenv import load_dotenv
import ccxt.async_support as ccxt
import aiohttp
from aiogram import Bot, Dispatcher, types
from aiogram.contrib.fsm_storage.memory import MemoryStorage
from aiogram.dispatcher import FSMContext
from aiogram.dispatcher.filters.state import State, StatesGroup
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.utils import executor

# --- Load Environment Variables ---
load_dotenv()
BOT_TOKEN = os.getenv("BOT_TOKEN")
ALLOWED_USERS = [int(user_id.strip()) for user_id in os.getenv("ALLOWED_USER_ID", "").split(",") if user_id]
WALLEX_API = "https://api.wallex.ir/v1"

# --- Exchange API Keys ---
EXCHANGES = {
    "binance": {"apiKey": os.getenv("BINANCE_API_KEY"), "secret": os.getenv("BINANCE_SECRET_KEY")},
    "bybit": {"apiKey": os.getenv("BYBIT_API_KEY"), "secret": os.getenv("BYBIT_SECRET_KEY")},
    "coinex": {"apiKey": os.getenv("COINEX_API_KEY"), "secret": os.getenv("COINEX_SECRET_KEY")},
}

# --- Bot Initialization (Using MarkdownV2) ---
storage = MemoryStorage()
bot = Bot(token=BOT_TOKEN, parse_mode=types.ParseMode.MARKDOWN_V2)
dp = Dispatcher(bot, storage=storage)

# --- Helper Function for MarkdownV2 ---
def escape_markdown(text: any) -> str:
    """Escapes special characters for Telegram MarkdownV2."""
    escape_chars = r'_*[]()~`>#+-=|{}.!'
    return str(text).translate(str.maketrans({char: f'\\{char}' for char in escape_chars}))

# --- FSM States ---
class PositionState(StatesGroup):
    pass # Can be expanded later

# --- Keyboard Layouts ---
def get_main_menu():
    keyboard = InlineKeyboardMarkup(row_width=2)
    keyboard.add(
        InlineKeyboardButton("🏦 صرافی‌ها", callback_data="menu_exchanges"),
        InlineKeyboardButton("📈 اطلاعات بازار", callback_data="menu_market_info")
    )
    return keyboard

def get_exchanges_menu():
    keyboard = InlineKeyboardMarkup(row_width=2)
    keyboard.add(
        InlineKeyboardButton("Binance", callback_data="exchange_binance"),
        InlineKeyboardButton("Bybit", callback_data="exchange_bybit"),
        InlineKeyboardButton("CoinEx", callback_data="exchange_coinex")
    )
    keyboard.add(InlineKeyboardButton("⬅️ بازگشت", callback_data="main_menu"))
    return keyboard

def get_exchange_actions_menu(exchange_name: str):
    keyboard = InlineKeyboardMarkup(row_width=2)
    keyboard.add(
        InlineKeyboardButton("💰 موجودی", callback_data=f"balance_{exchange_name}"),
        InlineKeyboardButton("📊 پوزیشن‌ها", callback_data=f"positions_{exchange_name}")
    )
    keyboard.add(InlineKeyboardButton("⬅️ بازگشت به صرافی‌ها", callback_data="menu_exchanges"))
    return keyboard

# --- API Fetching Functions ---
async def fetch_wallex_usdt_price():
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(f"{WALLEX_API}/markets") as response:
                if response.status != 200: return "N/A"
                data = await response.json()
                price = data.get("result", {}).get("symbols", {}).get("USDTTMN", {}).get("stats", {}).get("lastPrice")
                return f"{float(price):,.0f} تومان" if price else "N/A"
    except Exception:
        return "N/A"

async def fetch_exchange_prices(exchange_name: str, symbols: list):
    prices = {}
    exchange = await get_exchange(exchange_name)
    if not exchange: return prices
    try:
        tickers = await exchange.fetch_tickers(symbols)
        for symbol, ticker_data in tickers.items():
            prices[symbol.split('/')[0]] = ticker_data['last']
    except Exception as e:
        print(f"Could not fetch prices from {exchange_name}: {e}")
    finally:
        if exchange: await exchange.close()
    return prices

async def get_exchange(exchange_name: str):
    if exchange_name not in EXCHANGES: return None
    config = EXCHANGES[exchange_name].copy()
    exchange_class = getattr(ccxt, exchange_name)
    return exchange_class(config)

async def format_balance_message(balance_data, tickers):
    """Helper to format a specific balance section (e.g., Spot or Futures)."""
    message = ""
    total_usdt_value = 0
    balances_to_display = []

    for currency, amount in balance_data['total'].items():
        if amount > 0:
            usdt_value = 0
            if currency == 'USDT':
                usdt_value = amount
            elif f"{currency}/USDT" in tickers:
                usdt_value = amount * tickers[f"{currency}/USDT"]['last']
            
            if usdt_value > 1:
                balances_to_display.append({'coin': currency, 'total': amount, 'usdt': usdt_value})
                total_usdt_value += usdt_value
    
    balances_to_display.sort(key=lambda x: x['usdt'], reverse=True)

    for bal in balances_to_display:
        coin = escape_markdown(bal['coin'])
        total = escape_markdown(f"{bal['total']:.6f}".rstrip('0').rstrip('.'))
        usdt_val = escape_markdown(f"{bal['usdt']:,.2f}")
        message += f"*{coin}*: `{total}` \\(≈ ${usdt_val}\\)\n"
        
    return message, total_usdt_value

async def fetch_unified_balance(exchange_name: str):
    exchange = await get_exchange(exchange_name)
    if not exchange: return f"صرافی '{exchange_name}' پیکربندی نشده است\\."

    try:
        message = f"💰 *موجودی صرافی {exchange.name}*\n\n"
        grand_total_usdt = 0
        
        # Fetch all tickers once
        tickers = await exchange.fetch_tickers()

        if exchange_name == 'binance':
            # --- Binance: Fetch Spot and Futures separately ---
            # Fetch Spot Balance
            spot_balance = await exchange.fetch_balance()
            spot_message, spot_total = await format_balance_message(spot_balance, tickers)
            if spot_total > 1:
                grand_total_usdt += spot_total
                message += "*Spot*\n" + spot_message
                message += f"__Total Spot__: `${escape_markdown(f'{spot_total:,.2f}')}`\n\n"

            # Fetch Futures Balance
            futures_balance = await exchange.fetch_balance(params={'type': 'future'})
            futures_message, futures_total = await format_balance_message(futures_balance, tickers)
            if futures_total > 1:
                grand_total_usdt += futures_total
                message += "*Futures*\n" + futures_message
                message += f"__Total Futures__: `${escape_markdown(f'{futures_total:,.2f}')}`\n\n"

        else:
            # --- For Bybit, CoinEx, and others ---
            balance = await exchange.fetch_balance()
            balance_message, total_usdt = await format_balance_message(balance, tickers)
            grand_total_usdt += total_usdt
            if total_usdt > 1:
                message += balance_message

        if grand_total_usdt == 0:
            return f"موجودی قابل توجهی در صرافی {exchange.name} یافت نشد\\. لطفاً دسترسی کلید API خود را بررسی کنید\\."

        message += f"\n*موجودی کل کل*: `${escape_markdown(f'{grand_total_usdt:,.2f}')}`"
        return message

    except ccxt.AuthenticationError:
        return f"❌ *خطای احراز هویت* برای {exchange.name}\\!\n\nلطفاً مطمئن شوید کلیدهای API شما صحیح و معتبر هستند\\."
    except Exception as e:
        return f"خطا در دریافت موجودی {exchange.name}: {escape_markdown(str(e))}"
    finally:
        if exchange: await exchange.close()


# --- Telegram Handlers ---
@dp.message_handler(commands=["start"])
async def start_cmd(message: types.Message):
    if message.from_user.id not in ALLOWED_USERS:
        return await message.answer("❌ شما اجازه دسترسی به این ربات را ندارید\\.")
    await message.answer("سلام\\! به ربات مدیریت کریپتو خود خوش آمدید\\.", reply_markup=get_main_menu())

@dp.callback_query_handler(lambda c: c.data == "main_menu", state='*')
async def main_menu_handler(query: types.CallbackQuery, state: FSMContext):
    await state.finish()
    await query.message.edit_text("منوی اصلی:", reply_markup=get_main_menu())

@dp.callback_query_handler(lambda c: c.data == "menu_exchanges")
async def exchanges_menu_handler(query: types.CallbackQuery):
    await query.message.edit_text("لطفاً صرافی مورد نظر خود را انتخاب کنید:", reply_markup=get_exchanges_menu())

@dp.callback_query_handler(lambda c: c.data == "menu_market_info")
async def market_info_handler(query: types.CallbackQuery):
    await query.answer("در حال دریافت قیمت‌ها...")
    
    coins_to_fetch = ['BTC/USDT', 'ETH/USDT', 'SOL/USDT']
    
    wallex_task = fetch_wallex_usdt_price()
    binance_task = fetch_exchange_prices('binance', coins_to_fetch)
    bybit_task = fetch_exchange_prices('bybit', coins_to_fetch)
    
    usdt_price, binance_prices, bybit_prices = await asyncio.gather(
        wallex_task, binance_task, bybit_task
    )

    message = f"📈 *اطلاعات بازار*\n\n"
    message += f"🇮🇷 *قیمت تتر \\(والکس\\)*: `{escape_markdown(usdt_price)}`\n"
    message += "—\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\n\n"

    message += "*Binance*\n"
    for coin, price in binance_prices.items():
        message += f"*{coin}*: `${escape_markdown(f'{price:,.2f}')}`\n"
    message += "\n"

    message += "*Bybit*\n"
    for coin, price in bybit_prices.items():
        message += f"*{coin}*: `${escape_markdown(f'{price:,.2f}')}`\n"

    await query.message.edit_text(message, reply_markup=get_main_menu())


@dp.callback_query_handler(lambda c: c.data.startswith("exchange_"))
async def exchange_actions_handler(query: types.CallbackQuery):
    exchange_name = query.data.split("_")[1]
    await query.message.edit_text(f"صرافی *{escape_markdown(exchange_name.title())}* انتخاب شد\\. چه کاری می‌خواهید انجام دهید؟", reply_markup=get_exchange_actions_menu(exchange_name))

@dp.callback_query_handler(lambda c: c.data.startswith("balance_"))
async def get_balance_handler(query: types.CallbackQuery):
    exchange_name = query.data.split("_")[1]
    await query.answer(f"در حال دریافت موجودی از {exchange_name}...")
    msg = await fetch_unified_balance(exchange_name)
    await query.message.edit_text(msg, reply_markup=get_exchange_actions_menu(exchange_name))

@dp.callback_query_handler(lambda c: c.data.startswith("positions_"))
async def get_positions_handler(query: types.CallbackQuery):
    await query.answer("این قابلیت به زودی اضافه خواهد شد!", show_alert=True)

# --- Main Execution ---
if __name__ == "__main__":
    if not BOT_TOKEN or not ALLOWED_USERS:
        print("❌ ERROR: BOT_TOKEN and ALLOWED_USER_ID must be set in the .env file.")
    else:
        print("✅ Bot is running...")
        executor.start_polling(dp, skip_updates=True)
